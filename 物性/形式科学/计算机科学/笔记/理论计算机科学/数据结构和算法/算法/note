2.4 算法定义
算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。
2.5 算法的特性
算法具有五个基本特性：输入、输出、有穷性、确定性和可行性
2.5.1 输入输出
算法具有零个或多个输入，只少有一个或多个输出
2.5.2 有穷性
有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无线循环，并且每一个步骤在可接受的时间内完成。
2.5.3 确定性
确定性：算法的每一个步骤都具有确定的含义，不会出现二义性。算法在一定的条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确的定义而无歧义。
2.5.4可行性
可行性：算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限的次数完成。

2.6 算法设计的要求
2.6.1 正确性
正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反应问题的需求、能够得到问题的正确答案。
但是算法的“正确”通常在用法上有很大的区别，大体分为以下四个层次。
1.算法程序没有语法错误。
2.算法程序对合法的输入数据能产生满足要求的输出结果。
3.算法程序对于非法的输入数据能够得出满足规格说明的结果。
4.算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。

因为算法的正确性大部分情况下都不可能用程序来证明，而是用数据方法证明的。证明一个复杂的算法在所有层析上都是正确的，代价非常昂贵。所以一般情况下，我们把层次3作为一个算法时候正确的标准。
2.6.2 可读性
可读性：算法设计的另一个目的是为了便于阅读，理解和交流。
可读性高助于人们理解算法，晦涩难懂的算法往往隐含错误，不易被发现，并且难于调试和修改。
我们写代码的目的，一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读，让人理解和交流，自己将来也可能阅读，如果可读性不好，时间长了自己都不知道写了些什么。可读性是算法（也包括实现它的代码）好坏很重要的标志。
2.6.3 健壮性
健壮性：当输入数据不合法时，算法也能做出相关处理，而是产生异常或莫名奇妙的结果。
一个好的算法还应该能对输入数据不合法的情况做出合理的处理。比如输入时间或者距离不应该为负数等。
2.6.4 时间效率高和存储量低
设计算法应该尽量满足时间效率高和存储量底的需求。
在生活中，人们都希望花最少的钱，用最短的时间，办最大的事，算法也是一样的思想，最好用最少的空间，花最少的时间，办成同样的事就是好的算法。

2.7 算法效率的度量方法
2.7.1事后统计方法
事后统计方法：这种方法主要通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。
2.7.2 事前分析估计方法
事前估计分析方法：在计算机程序编制前，依据统计方法对算法进行估算。

一个高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：
1. 算法采用的策略、方法。（算法好坏的根本）
2. 编译产生的代码质量。（软件来支持）
3. 问题的输入规模。
4. 机器执行指令的速度。（硬件性能）
抛开1、2、4，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少。
最终，在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。
2.8 函数的渐进增长
函数的渐近增长：给定两个函数f（n）和g（n），如果存在一个整数N，使得对于所有的n > N,f(n)总是比g（n）大，那么，我们说f（n）的增长渐进快于g（n）。
判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。

2.9 算法时间复杂度
2.9.1 算法时间复杂度定义
在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况确定T（n）的数量级。算法的复杂度，也就是算法的时间度量，记做：T(n)=O（f（n））。它表示随问题规模n的增大，算法执行时间的增长率和f（n）的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。其中f（n）是问题规模n的某个函数。这样用大写O（）来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着n的增大，T（n）增长最慢的算法为最优算法。
我们三个求和算法的时间复杂度分别为O(n)，O（1），O（n2）。我们分别给它们取了非官方的名称，O（1）叫常数阶、O（n）叫线性阶、O（n2）叫平方阶等等.
2.9.2 推导大O阶方法
推导大O阶：
1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。
得到的结果就是大O阶。
2.9.3 常数阶
执行次数不随输入量的增大而是常数阶，是一个固定的常数。
2.9.4 线性阶
分析算法的复杂度，关键就是要分析循环结构的运行情况。
2.9.5 对数阶
2.9.6 平方阶
理解大O推导不算难，难的是对数列的一些相关运算，这更多的是考察你的数学知识和能力。
2.10 常见的时间复杂度
12             O（1）    常数阶
2n+3           O（n）    线性阶
3n2+2n+1       O（n2）   平方阶
5log2n+20      O（nlogn）对数阶
2n +3nlog2n+19 O（nlogn）nlogn阶
6n3+2n2+3n+4   O(n3)     立方阶
2n             O（2n）   指数阶

2.11 最坏情况与平均情况
最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。

一般在没有特殊说明的情况下，都是指最坏时间复杂度。

2.12 算法空间复杂度
算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O（f（n）），其中，n为问题的规模，f（n）为语句关于n所占存储空间的函数。在n的规模较大的时候硬件的重要性就比不上算法的重要了。





