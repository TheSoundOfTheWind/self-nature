1. Q_Q指针与Q_D指针类似，在原理上是一致的，只是在概念中用法不一样，Q_D指针一般用来访问“private”类中的数据的数据。Q_Q指针则是通过private类访问“public”类，private类就是装钱的钱包，public就是口袋。
2. ./configure -developer-build -prefix ./build -confirm-licence -opensource
3. widget 和widget一般都插入一个layout的空间用于定位这两个widget之间的排版，位置。
首先，我要明确地说Qt 3D不会消失。Kuesa和其他项目上正在使用Qt 3D，其他公司甚至还在一些非常大的商业应用上使用Qt 3D。

我们知道Qt 3D存在不少性能问题，正如您可能已从gerrit上看到了大量的更新，我们已在非常努力地解决这些问题。下面让我们简要梳理一下正在发生的事情和未来计划。

多线程架构
从一开始，Qt 3D就被设计成多线程模式。通常来说这是件好事，但是随着异步性的增加，事情会变得棘手。在一些没有良好内存分配器或信号量实现不理想的低端嵌入式硬件上，多线程实际上可能会碍事。

为了提升这块性能，我们在Qt 5.14中去掉了所谓的Aspect Thread。仍有一个线程池来并行化任务处理，但是可以通过一个环境变量控制。

在常规场景中去掉帧缓存对象（FBO）
在执行3D内容渲染、再叠加2D UI的常规场景中，Qt 3D不再只能使用帧缓存对象（FBO）了。这种方式首先将3D内容渲染到FBO附加的颜色纹理（以及深度纹理）中，这是OpenGL必须要设置的渲染目标。然后Qt Quick把同一个颜色纹理映射到一个简单四边形上，最后与Qt Quick 2场景的其余部分合成。

这个方式在桌面和许多设备上都没有问题。然而，有些设备的FBO实现非常差，会极大降低性能。如果3D内容严格地位于UI下层并使用简单的渲染方式（通常是正向渲染），那么我们可以对其进行优化，完全避免使用FBO代码路径。这时，我们可以命令Qt 3D直接在屏幕上绘制，因为我们明白所有Qt Quick内容都会在这个基础上覆盖。要启用此优化，应使用Scener3D全新的compositingModeproperty（Qt 5.14起），并设置为Underlay。非常感谢Giuseppe D’Angelo实现了这一点，以及Paul Lemire做的集成。

优化消息系统（Notification System）
第三个大变化领域，也是仍在进行中的领域，是改变我们在Qt 3D前、后端发送/接受属性变化通知的方式。到目前为止，这是通过为每一个属性变化传递类似事件的数据包来实现。在有成千上万个实体和许多动画属性的大规模场景中，这就会让性能陷入泥沼，并成为瓶颈。

在考虑各种选择后，Mike Krus和Paul Lemire一直十分努力地重新设计这个重要的子系统，以提高性能。新机制是基于当前端和后端对象变dirty后直接同步的原理。这让一个对象上的所有属性可以一次性全部更新，而不是每次调用只更新一个属性。当前基准测试结果表明，在大规模场景（数千个实体）中，属性变更通知分发速度加快了200~300%。

如果一切顺利，以上这些修改都会在未来的Qt 5.14.x版本中落地。

总结
除了以上改进，我们还在整个代码库中引入了许多小的提升。例如，frame graph的遍历现在只在frame graph中发生了实质性影响输出的变化时发生。另外还有仅当uniforms的值改变后才会更新的优化。

在Qt 5.14系列中我们对Qt 3D进行了许多优化，并且将来还有更多。这些提升大大降低了CPU渲染帧时额外的CPU开销，同时减少了线程同步的数量，因为线程同步可能会导致有些系统上的时间浪费。

下一篇文章我们将深入探究为在Qt 6中提升Qt 3D所作的研究，以及如何利用现代图形API来实现更高的性能。


