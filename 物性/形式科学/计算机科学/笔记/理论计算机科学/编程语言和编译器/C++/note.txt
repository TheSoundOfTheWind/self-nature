1.public inheritance (公共继承)不是has-a关系而是is-a关系。
 继承 is-a 子类是父类，即子类是父类的一种，水果和香蕉，动物和鸭子。
 has-a是包含关系，是组合关系。比如午餐和香蕉。午餐吃完了，香蕉自然也不存在了，是整体和部分的关系。这就和聚合关系不同了，聚合是主体消失了个体还能独立存在。班级和班级中的学生。
 类与类之间的关系只有两种，要么是is-a（继承）要么是has-a是（依赖，关联，聚合，组合）。

2.当你发现一段代码老出现bug时，那就重写他，让他变得完美，结构，内存，逻辑返回值，个方面都完美，这样就没有bug，计算机执行没有bug，有bug的是代码结构和逻辑。

3.一些问题找不到根，可以空闲时间去debug，工作时间全用来开发新的功能。

4.方法在头文件中放置的顺序，不应该受数据成员的影响

5.方法可以按权限和方法长度来排序和get，set方法来排序，数据成员还是按照数据的类型来分类,同一数据类型的数据成员，可以按数据成员的命名长度来分类。数据成员不宜按功能分，不然和一个结构体没区别，而且结构体还有名字，可以把几个数据类型压缩成一种类型。

6.写代码就好比打铁，一块精铁要经过反复的锤打，高温的粹烤才能筛出铁中渣滓，让精铁更纯粹。一段好的代码也是，反复的重构，反复的提炼保留其精华，去除其糟粕。让设计和实现都达到完美才是一段好代码。

7.保留虚函数标签仅仅在子类需要重新定义他的时候，才保留。也就是子类会重新定义这个函数的时候用这个关键字。如果不会重新定义就不用，提高性能。

8,类的设计不是线性的，有时候你也不知道把这个方法放在哪个类中合适。

9.虚函数就是同一个方法名在不同的类中有不同的实现就这样用就很合适，等于同一个函数实现不一样，功能也略有差别。

10.逻辑越复杂的代码不是好代码，要精简优雅，冗余度低。

11.const A & a = .....。一旦用const修饰，就只能调用const修饰的函数，注意不是返回const B &的函数而是 void a() const;用const修饰的函数。get函数可以全部用const去修饰，只是为了值而不是要修改，如果你要用到这个类中的非const函数，就不能用const去修饰了。

12.写代码要时刻保持优雅，因为后期你会不断去处理新的code，原来乱糟糟的code可能会永远乱糟糟的，没有时间和人员去完善，完善一段code和写一段code时间差不多，宁愿多花一点时间也要力求代码的优雅，简洁，有力，不然后期会花很多时间在代码的维护上。

13.如果程序闪退，用gdb进去，然后where看有没什么错误的信息在栈里

14.构造函数和其他函数存在不同，构造函数是用来新建对象的，而其他函数是被新建出来的对象调用的。

15.如果一个类作为基类，那么必须为这个类定义析构函数，为了让子类更好的继承到，最好在头文件去定义这个析构函数。

16.永远不把一个任务交付给你没能理清它内部结构的代码，不然胆战心惊，不得安宁。

17.传递参数最好用粒度最小的数据类型，而不是用复杂的结构体，这样不利于维护。当结构体发生变动时，其它和这个结构体相关的代码都会收到波及。简而言之，自定的结构体最好不要发生跨层作为参数传递。函数内部用到什么数据就传什么数据，而不是把一个大的结构体传递进去。这样函数与外界耦合就小，只存在必要的传入参数的耦合，这样功能也很专精，明确。就像组装一个复杂的机器人一样，每个零件之间都是通过基础类型的参数传递信息，沟通，当其中一个零件损坏需要更换，也不会让其他零件受到波及。每个零件可以很独立的去优化，因为他的分工更明确，没有其他零件和它做同样的工作，他也可以将她所负责的工作做到极致。接口原则上最好保持不变，用基础类型作为参数能很好的保持这条原则，因为基础类型无法修改，如果用自定义类型，那意味着参数的类型本身就变得不可靠起来。更不用说参数签名（类型和长度）所带来的变动。如果你用自定义的类型作为参数传递，这个类型又被其他类型涵盖，并多级传递，一点最内部的自定义的类型发生变动，那么维护带来的成本是极大的。
碰到迫不得已需要用复杂类型的时候时候尽量也别用结构体，就用类来。类的内部就是基础的数据类型，然后其他复杂的类包含这个类，构成更复杂的类型。这样做的好处是会对数据进行封装，将数据保护起来，用函数或者说接口来调用。类的内部也可以对数据进行处理，保证通过接口调用的数据都是基础类型。最外层的那个巨大无比的类型，我也可以在这个类型中拿到想要的基础类型数据，而且是处理好的数据。通过这些基础数据作为传递的媒介，耦合度就会迅速下降。
定义的再好的数据类型，只要它不是基础类型，就不够灵活，但是有时候总不能用太基础的类型，这个时候也最好用第三方库自带的很规范很完整的次基础类型，反正无论如何都尽量不要用自定义的结构体或类。优先级从，基础->第三方类->自定义类->自定义结构体。

18.int a() const; 如果一个函数加const修饰，那么就表示函数内部不能修改调用的对象。所以在get函数中应该使用const修饰。

19.当出现两个变量都会影响结果时，你必须将其中一个变量所产生的影响确认下来，不然你通过调整另一个变量以此来得到正确结果是不可能的。换句话说，如果你通过调整一个变量以此来想得到正确的效果，却无论如何也得不到正确结果，那么很有很能，控制效果的输入数据不止这一个变量，你调整这个变量的时候其他变量也在变，所以无论怎么调你都不能得到一个自洽的结果。这个时候你需要将其他变量限定死。

20.调试的时候，必须将输入数据简单话，具有调表性，这样才能让你迅速回归问题本身，而不是被复杂的输入数据所干扰。影响你得判断。

21.写代码是为了给人们的生活和工作带来便利的，代码本身复不复杂不是我们需要关注的，而关注的是代码所带来的效果能不能给我们的生活带来便利。代码对于创造它的程序员来说也要尽量做到结构简单，直指问题的核心。如果一句代码能实现的工作觉不用两行代码来实现，同一个目标用的代码越多越难维护。在完成一段逻辑处理的时候逻辑清晰，并且代码简洁有力。这样会给人一种原来这么简单，但简单里又有一种智慧在。计算机的核心就是01两个状态的变换，越简单越清晰的逻辑，组合起来才能爆发更强大的力量。不要写一大段似是而非的代码，目标不清晰逻辑也不清晰，没有干净利落的明确的目标，代码写的臃肿不堪。作为程序员一定要明白，在复杂的逻辑结构或逻辑语句也能通过分层拆分成简单的清晰的逻辑片段和小的功能点来实现。
  如果本来可以用10行代码的来实现的code你用了50行来实现，那么这段代码逻辑一定比较混乱，逻辑思路一定不清晰。一定要明白，功能强大的代码不是看起来复杂的代码而是逻辑清晰有力的代码，通过相互配合得当才显得强大。

22.写完一个类，这个类所有的数据成员都要写好它的get和set方法，便于调用，这样也保证了这个类与外界交互的能力，不要等用到的时候再去加，这样会让类看起来不完整。不完整的类在后期的使用中给人的感觉很不友好，会让这个类的维护性大大下降。特别是一个基础数据类，存储数据用的类，更是如此。你在逻辑操作类中可以指写一些功能函数，但是基础类中不能如此。

23.不加const修饰的函数参数，也就是说可以通过这个参数调用这个参数对象内部的非consts函数。如果是传引用或传指针调用，这样做就要当心。

24.不加const修饰的函数返回值，如果是返回对象内部的数据成员，一般会用指针或引用返回，如果不加const修饰，那么这个返回的对象可以调用本对象内部非const修饰的函数。

25.不要尝试在一个集合的类中去重写组合它的类中的方法，有多个类组合这个对象是会造成混乱，代码也变得臃肿和不清晰。

26.一个对象中的方法可以分成三类，一类是set方法这类方法的特征是会改变这个对象的数据成员，一类是get方法这个方法的特征是获取对象内部的数据成员，但是不会改变他。一类是功能函数，这类函数的特征是不能获取对象内部的数据成员的值，也不修改对象内部的数据成员。就好某机器人是一个对象，你可以通过set函数修改这个机器人参数来改变这个机器人的外貌和动作，你也可以通过get函数获取这个机器人目前的信息，从而更好的控制机器人。而普通函数则是一些机器人正常运转的维护工具就好比扳手一样，能够帮机器人更好运转但是却不是机器人的一部分，也不属于他的行为的一部分，而被输入数据改变和反馈数据就是机器人的行为了，普通函数内部处理的只是参数传入的数据和数据成员没有任何耦合。
set methods:会直接或间接改变数据成员的值,
get methods:需要数据成员才能得出数据，但是不会改变数据成员的值
utility methods:不需要数据成员就能得到数据或处理数据
而set方法又可以按修改的特征类型不同，模块不同归类，get方法也可以按反馈的数据种类归类。

27.要按方法的功能，作用方向来安置在头文件中的顺序和源文件的顺序，而不应该根据方法的权限大小，方法的长短来，这对于维护来说帮助不大，为应该将方法分成一类一类的，划分到set，get，utility下，这样方便管理和维护的多。

28. get methods:都是以const修饰函数，确保这是一个合格的get函数，如果返回的是类中的数据成员一般用const Type &来修饰返回值，这样可以固定开销，每次返回就是一个引用的copy和函数调用的开销，如果返回的不是函数成员那只能用值返回。这是copy返回，如果返回的类比较大建议少用，用其他方式实现。

29.set方法一般都用void修饰，但是如果想了解set执行的状态可以用一个bool值作为返回值。一般也就这两种了。

30.构造函数是是初始化数据，从系统中获取存储数据的空间并给这些空间的数据赋予初值，set get方法是一个过程，对已有的数据的处理过程， 析构函数是将存储数据的空间还给操作系统

31. 当一个int型的数和一个unsigned int型比较大小时要注意，如果这个unsigned int 进行减法可能变成负数，int a； unsigned int b = x-1； a 大于 b很可能不成立，虽然a为正数b为负数。要int（b），把b转为int再比较才行。