Ray tracing中，每条光线都需要和场景中所有的图元求交
（这里我们假设所有的图元都是三角形）。Brute force的
方法就是一点一点的遍历每个图元，然后找出与光线交点距
离光线起始点最近的图元，当然这种方法的算法复杂度是O(N)
的，对于少量的图元还可以，如果图元数量很多，光线跟踪
的过程将非常慢。
事实上，大部分的图元距离光线都是非常远的，只有一小部分
的图元有可能与光线相交，所以没有必要遍历所有图元。利用
空间划分结构，可以快速的把无关三角形去除掉，从而只遍历
很小的一部分子集，就可以找到最近的交点。其中比较常用的
有Uniform grid，kd-tree，Bounding Volume Hierarchy (BVH)。

Uniform Grid，即均匀网格，就是把空间均匀划分，每个图元
被分配到与其相交的所有节点中。注意这里一个图元可以被分
配到多个格子中，而每个格子可能有多个图元在其中。这种分
割方式的优势在于，实现起来非常简单，而且创建速度是最快
的，把图元分配到格子中可以在O(1)的时间内搞定。然而，由
于在创建过程中，对于空间中图元的分布没有任何的考虑，所
以这种分割算法的遍历效率并不高。对于比较实际的场景而言，
效率很可能会不好。比如，如果场景中的1%的空间中包含了90%
的图元，这些图元很可能被分配到很少的几个格子里面。换个
角度思考，每个格子会有很多的图元，从而当光线遍历过的时
候，需要遍历90%的图元，效率是非常低下的。即如果场景中的
图元分布不够均匀，均匀网格的遍历效率会有很大的问题。

KD-Tree，K-Dimensional tree，可以更好的适应空间中的不均
匀分布的图元。在图元多的地方，kd-tree会相对分割细致一些
，而图元少的地方，就会分割的粗糙一些。一般来说，kd-tree
都是基于一种叫做sah的模型来分割的。有很多种不同的分割策
略，其中在单线程的环境下，创建kd-tree的理论复杂度下限为
O(N*log(N))。由于考虑的场景中的图元分布，kd-tree在遍历
的过程中，有着很大的性能提升。然而，build一棵质量较优的
kd-tree一般要很长时间(基于GPU的实时kd-tree创建算法已经
被提出)。

BVH，层次包围盒。uniform grid和kd-tree都是相对于空间进
行划分，然后把图元分配到不同的节点中。而bvh换了一种角度
，它会划分图元，而不是空间。一个图元在bvh中只可能出现一
次，而节点在空间中是可能有重叠的。bvh与kd-tree有很多的相
似，但是也有一些特性，bvh的内存是有上限的，由于图元的数
量不会因为划分而增长，所以需要开辟的空间是可以预先计算的
，而节点的数量也不会超过2*N-1（N为图元的数量）。相对于
kd-tree而言，bvh的创建过程会更廉价一些，但是遍历效率会低一些。
