1.构造函数存在的作用就是用来合理的初始化成员变量

2.函数传一个对象的值和传一个对象的引用，一般情况下最好传引用，因为传值调用了copy函数和析构函数，而传引用的消耗仅仅时引用本身的copy，是一个指针类型的变量，消耗是固定的而传值的消耗是不固定的随着对象的增大消耗会急剧增加，如果调用多次时间上的消耗积累下来是可观的。但是传引用时要注意，如果不希望函数内部改变传入引用的值用const保护该引用。

3.返回一个对象的值和返回一个对象的引用，同理返回一个值的会产生对象的临时copy对象，这是一个消耗。相对与返回引用来说这个消耗随着对象的不同和调用次数的大小，时间消耗变得很可观。返回引用时，同理，如果你不想改变引用的值只是想或许引用里的值需要用const对返回的引用加以修饰。而且有一点要注意，当这个返回的对象不是类的数据成员或者作用域更大的成员，仅仅时函数内部的成员这个时候就不能用返回引用了，必须得使用返回值，因为函数作用域当函数执行完之后内部所有的临时变量的内存都会被释放，需要用返回值的方式把函数内部的值copy到函数作用域之外的作用域。

4.explicit出现是为了防止隐式的转换，当构造函数类似这样的形式：
Star(const char *); // converts char * to Star
Star(const Spectral &, int member = 1); // converts Spectral to Star
如果不加explicit去限定这类的构造函数，那么就可以
Start north;
north = "polaris";出现这样莫明奇妙的用法，这是因为赋值函数右边的"polaris",会默认调用Start(const char *)，使其变成一个Star对象，然后再对这个对象进行赋值操作。
加了explicit Star()；之后就只能显式的调用了，只能这样，north = Star("polaris");

5.